-- Settlement Template for Canton DCN
-- Represents settlement operations in the decentralized clearing network

module Settlement where

import DA.List

-- Settlement Request Template
template SettlementRequest
  with
    operator : Party
    settlementId : Int
    exchangeId : Int
    sessionId : Int
    participants : [Party]      -- Parties involved in settlement
    transfers : [Transfer]      -- List of transfers to execute
    status : SettlementStatus
    createdAt : Time
  where
    signatory operator
    observer participants
    
    key (operator, settlementId) : (Party, Int)
    maintainer key._1
    
    -- Choice to approve settlement
    choice ApproveSettlement : ContractId SettlementRequest
      with
        approver : Party
      controller approver
      do
        assertMsg "Approver must be a participant" (elem approver participants)
        create this with status = Approved
    
    -- Choice to execute settlement with validation
    choice ExecuteSettlement : ContractId SettlementRequest
      controller operator
      do
        assertMsg "Settlement must be approved" (status == Approved)
        assertMsg "Transfers must not be empty" (not $ null transfers)
        
        -- Validate all transfers
        forA_ transfers $ \transfer -> do
          assertMsg "Transfer validation failed" (validateTransfer transfer)
        
        -- Check for duplicate nonces (replay protection)
        let nonces = map (\t -> t.nonce) transfers
        let uniqueNonces = DA.List.dedup (DA.List.sort nonces)
        assertMsg "Duplicate nonces detected" (length nonces == length uniqueNonces)
        
        create this with status = Executed
    
    -- Choice to cancel settlement
    choice CancelSettlement : ContractId SettlementRequest
      with
        reason : Text
      controller operator
      do
        create this with status = Cancelled

-- Transfer data structure with enhanced validation
data Transfer = Transfer
  with
    fromUserId : Int
    toUserId : Int
    assetId : Int
    amount : Decimal
    nonce : Int              -- Replay protection
    maxAmount : Optional Decimal  -- Optional maximum transfer limit
  deriving (Eq, Show)

-- Validation helper for transfers
validateTransfer : Transfer -> Bool
validateTransfer transfer =
  transfer.amount > 0.0 &&  -- Amount must be positive
  transfer.fromUserId /= transfer.toUserId &&  -- Cannot transfer to self
  case transfer.maxAmount of
    None -> True
    Some max -> transfer.amount <= max  -- Respect maximum if set

-- Settlement status
data SettlementStatus = Pending | Approved | Executed | Cancelled | Failed
  deriving (Eq, Show)

-- Multi-party Settlement Template with balance validation
template MultiPartySettlement
  with
    operator : Party
    settlementId : Int
    parties : [Party]
    balanceChanges : [(Int, Int, Decimal)]  -- (userId, assetId, change)
    signatures : [Party]
    isComplete : Bool
    minSignatures : Int       -- Minimum signatures required
  where
    signatory operator
    observer parties
    
    key (operator, settlementId) : (Party, Int)
    maintainer key._1
    
    -- Validate that balance changes net to zero (conservation of value)
    ensure 
      let groupedByAsset = DA.List.groupOn (\(_, assetId, _) -> assetId) 
                                           (DA.List.sortOn (\(_, assetId, _) -> assetId) balanceChanges)
          assetSums = map (\changes -> 
                            foldl (\acc (_, _, amount) -> acc + amount) 0.0 changes) 
                          groupedByAsset
      in all (\sum -> abs sum < 0.000001) assetSums  -- Net to zero (with floating point tolerance)
    
    -- Choice to add signature with validation
    choice AddSignature : ContractId MultiPartySettlement
      with
        signer : Party
      controller signer
      do
        assertMsg "Signer must be a party" (elem signer parties)
        assertMsg "Already signed" (notElem signer signatures)
        let newSignatures = signer :: signatures
        let complete = length newSignatures >= minSignatures
        create this with 
          signatures = newSignatures
          isComplete = complete
    
    -- Choice to finalize settlement with full validation
    choice FinalizeSettlement : ()
      controller operator
      do
        assertMsg "Settlement must be complete" isComplete
        assertMsg "Minimum signatures required" (length signatures >= minSignatures)
        assertMsg "All balance changes must be non-zero" 
          (all (\(_, _, amount) -> amount /= 0.0) balanceChanges)
        return ()
